{% extends "admin_navigation.html" %}

{% block title %}Szablony testów - AI Rekruter{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1>Szablony testów</h1>
    <button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#addTestModal">
        Dodaj szablon testu
    </button>
</div>

<!-- Update filters and sort section -->
<div class="card mb-4">
    <div class="card-body">
        <form class="row g-3">
            <!-- First row -->
            <div class="col-md-6 col-lg-3">
                <label class="form-label">Typ testu</label>
                <select class="form-select" id="filterTestType">
                    <option value="">Wszystkie</option>
                    <option value="SURVEY">Ankieta</option>
                    <option value="EQ">Test EQ</option>
                    <option value="IQ">Test IQ</option>
                </select>
            </div>
            
            <div class="col-md-6 col-lg-3">
                <label class="form-label">Grupa</label>
                <select class="form-select" id="filterGroup">
                    <option value="">Wszystkie</option>
                    {% for group in user_groups %}
                        <option value="{{ group.id }}">{{ group.name }}</option>
                    {% endfor %}
                </select>
            </div>

            <div class="col-md-6 col-lg-3">
                <label class="form-label">Sortuj według</label>
                <select class="form-select" id="sortBy">
                    <option value="created_at">Data utworzenia</option>
                    <option value="time_limit">Limit czasu</option>
                    <option value="questions">Liczba pytań</option>
                </select>
            </div>

            <div class="col-md-6 col-lg-3">
                <label class="form-label">Kolejność</label>
                <select class="form-select" id="sortOrder">
                    <option value="desc">Malejąco</option>
                    <option value="asc">Rosnąco</option>
                </select>
            </div>

            <!-- Second row - buttons -->
            <div class="col-12 d-flex justify-content-end gap-2 mt-3">
                <button type="button" class="btn btn-outline-secondary" id="resetFilters">
                    Resetuj filtry
                </button>
                <button type="button" class="btn btn-primary" id="applyFilters">
                    Zastosuj
                </button>
            </div>
        </form>
    </div>
</div>

<div class="table-responsive">
    <table class="table table-striped">
        <thead>
            <tr>
                <th>Tytuł</th>
                <th>Typ testu</th>
                <th>Limit czasu</th>
                <th>Liczba pytań</th>
                <th>Suma punktów do zdobycia</th>
                <th>Próg zaliczenia</th>
                <th>Grupy</th>
                <th>Data utworzenia</th>
                <th>Akcje</th>
            </tr>
        </thead>
        <tbody>
            {% for test in tests %}
            <tr data-test-id="{{ test.id }}" 
                data-groups='{{ test.groups|tojson|safe }}'
                ondblclick="editTest('{{ test.id }}')" 
                style="cursor: pointer;">
                <td>{{ test.title }}</td>
                <td>
                    {% if test.test_type == 'SURVEY' %}
                        Ankieta
                    {% elif test.test_type == 'EQ' %}
                        Test EQ
                    {% elif test.test_type == 'IQ' %}
                        Test IQ
                    {% endif %}
                </td>
                <td>{{ test.time_limit_minutes }} min</td>
                <td>{{ test.question_count }}</td>
                <td>{{ test.total_points }}</td>
                <td>{{ test.passing_threshold }}</td>
                <td>
                    {% if test.groups %}
                        {% for group in test.groups %}
                            <span class="badge bg-secondary me-1">{{ group.name }}</span>
                        {% endfor %}
                    {% else %}
                        <small class="text-muted">Brak przypisanych grup</small>
                    {% endif %}
                </td>
                <td>{{ test.created_at|datetime }}</td>
                <td>
                    <div class="btn-group">
                        <button type="button" class="btn btn-sm btn-warning" 
                                onclick="editTest('{{ test.id }}')">Edytuj</button>
                        <button type="button" class="btn btn-sm btn-info" 
                                onclick="duplicateTest('{{ test.id }}')">Duplikuj</button>
                        <button type="button" class="btn btn-sm btn-danger" 
                                onclick="confirmDeleteTest('{{ test.id }}')">Usuń</button>
                    </div>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>

<!-- Add Test Modal -->
<div class="modal fade" id="addTestModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Dodaj nowy szablon testu</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="addTestForm" method="POST" action="{{ url_for('test.add') }}">
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Tytuł testu* <span class="text-muted">(Wewnętrzna identyfikacja testu)</span></label>
                            <input type="text" class="form-control" name="title" required>
                        </div>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Typ testu*</label>
                            <select class="form-select" name="test_type" required>
                                <option value="SURVEY">Ankieta</option>
                                <option value="EQ">Test EQ</option>
                                <option value="IQ">Test IQ</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Opis testu <span class="text-muted">(Opis wyświetlany na stronie testu dla kandydata)</span></label>
                            <textarea class="form-control" name="description" rows="2"></textarea>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Próg zaliczenia* <span class="text-muted">(Ustaw wartość 0, aby test był traktowany jako bez progu)</span></label>
                            <input type="number" class="form-control" name="passing_threshold" required min="0">
                        </div>
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Limit czasu (minuty)</label>
                            <input type="number" class="form-control" name="time_limit_minutes" min="0">
                        </div>
                    </div>

                    <!-- Add this section in the Add Test Modal, right after the time_limit_minutes input -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Grupy*</label>
                            <div class="form-group">
                                <div class="border rounded p-3" id="addGroupsContainer">
                                    {% for group in groups %}
                                    <div class="form-check">
                                        <input type="checkbox" class="form-check-input group-checkbox" 
                                               name="groups[]" value="{{ group.id }}" 
                                               id="add_group_{{ group.id }}">
                                        <label class="form-check-label" for="add_group_{{ group.id }}">
                                            {{ group.name }}
                                        </label>
                                    </div>
                                    {% endfor %}
                                </div>
                                <div class="invalid-feedback" style="display: none;">
                                    Aby zapisać test, musisz wybrać przynajmniej jedną grupę
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Questions Section -->
                    <div class="questions-section mt-4">
                        <h6 class="mb-3">Pytania</h6>
                        <div class="questions-container"></div>
                        <div class="text-end mt-3">
                            <button type="button" class="btn btn-secondary add-question">
                                Dodaj pytanie
                            </button>
                        </div>
                    </div>

                    <div class="text-end mt-4">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Anuluj</button>
                        <button type="submit" class="btn btn-primary ms-2" id="addTestSubmit">
                            <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                            <span class="button-text">Zapisz test</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Edit Test Modal -->
<div class="modal fade" id="editTestModal" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Edytuj szablon testu</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="editTestForm" method="POST">
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Tytuł testu*</label>
                            <input type="text" class="form-control" name="title" required>
                        </div>
                    </div>
                    
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Typ testu*</label>
                            <select class="form-select" name="test_type" required>
                                <option value="SURVEY">Ankieta</option>
                                <option value="EQ">Test EQ</option>
                                <option value="IQ">Test IQ</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Opis testu</label>
                            <textarea class="form-control" name="description" rows="2"></textarea>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Próg zaliczenia* <span class="text-muted">(Ustaw wartość 0, aby test był traktowany jak bez progu)</span></label>
                            <input type="number" class="form-control" name="passing_threshold" required min="0">
                        </div>
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Limit czasu (minuty)</label>
                            <input type="number" class="form-control" name="time_limit_minutes" min="0">
                        </div>
                    </div>

                    <!-- Add groups section -->
                    <div class="row mb-3">
                        <div class="col-12">
                            <label class="form-label">Grupy*</label>
                            <div class="form-group">
                                <div class="border rounded p-3" id="editGroupsContainer">
                                    {% for group in groups %}
                                    <div class="form-check">
                                        <input type="checkbox" class="form-check-input group-checkbox" 
                                               name="groups[]" value="{{ group.id }}" 
                                               id="edit_group_{{ group.id }}">
                                        <label class="form-check-label" for="edit_group_{{ group.id }}">
                                            {{ group.name }}
                                        </label>
                                    </div>
                                    {% endfor %}
                                </div>
                                <div class="invalid-feedback" style="display: none;">
                                    Aby zapisać test, musisz wybrać przynajmniej jedną grupę
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Questions Section -->
                    <div class="questions-section mt-4">
                        <h6 class="mb-3">Pytania</h6>
                        <div class="questions-container"></div>
                        <div class="text-end mt-3">
                            <button type="button" class="btn btn-secondary add-question">
                                Dodaj pytanie
                            </button>
                        </div>
                    </div>

                    <div class="text-end mt-4">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Anuluj</button>
                        <button type="submit" class="btn btn-primary ms-2" id="editTestSubmit">
                            <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                            <span class="button-text">Zapisz zmiany</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Update Toast Container -->
<div class="toast-container position-fixed top-0 start-50 translate-middle-x p-3" style="z-index: 1070;">
    <div id="notificationToast" class="toast border-0" role="alert" aria-live="assertive" aria-atomic="true" style="min-width: 400px;">
        <div class="d-flex align-items-center justify-content-between p-3">
            <span id="toastMessage" style="font-size: 1.1rem;"></span>
            <button type="button" class="btn-close btn-close-white ms-3" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    </div>
</div>

<!-- Update JavaScript for filtering and sorting -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const filterTestType = document.getElementById('filterTestType');
    const filterGroup = document.getElementById('filterGroup');
    const sortBy = document.getElementById('sortBy');
    const sortOrder = document.getElementById('sortOrder');
    const applyFilters = document.getElementById('applyFilters');
    const resetFilters = document.getElementById('resetFilters');
    
    // Store original table rows
    const tbody = document.querySelector('tbody');
    const originalRows = Array.from(tbody.querySelectorAll('tr'));
    
    // Add button click handlers
    applyFilters.addEventListener('click', function() {
        updateTable(true);
    });
    
    resetFilters.addEventListener('click', function() {
        // Reset filter values
        filterTestType.value = '';
        filterGroup.value = '';
        sortBy.value = 'created_at';
        sortOrder.value = 'desc';
        
        // Restore original rows and order
        updateTable(false);
    });
    
    function updateTable(applyFilters) {
        const tbody = document.querySelector('tbody');
        
        if (!applyFilters) {
            // Reset to original state
            tbody.innerHTML = '';
            originalRows.forEach(row => {
                tbody.appendChild(row.cloneNode(true));
            });
            return;
        }
        
        // Clone original rows for filtering
        let rows = originalRows.map(row => row.cloneNode(true));
        
        // Apply filters
        if (filterTestType.value || filterGroup.value) {
            rows = rows.filter(row => {
                const testType = row.querySelector('td:nth-child(2)').textContent.trim();
                const testGroups = JSON.parse(row.dataset.groups || '[]');
                
                const testTypeMatch = !filterTestType.value || 
                    (filterTestType.value === 'SURVEY' && testType === 'Ankieta') ||
                    (filterTestType.value === 'EQ' && testType === 'Test EQ') ||
                    (filterTestType.value === 'IQ' && testType === 'Test IQ');
                    
                const groupMatch = !filterGroup.value || 
                    testGroups.some(group => group.id === parseInt(filterGroup.value));
                
                return testTypeMatch && groupMatch;
            });
        }
        
        // Apply sorting
        if (sortBy.value) {
            rows.sort((a, b) => {
                const aValue = getRowValue(a, sortBy.value);
                const bValue = getRowValue(b, sortBy.value);
                
                const order = sortOrder.value === 'asc' ? 1 : -1;
                
                if (typeof aValue === 'string') {
                    return aValue.localeCompare(bValue) * order;
                }
                
                if (aValue < bValue) return -1 * order;
                if (aValue > bValue) return 1 * order;
                return 0;
            });
        }
        
        // Update table
        tbody.innerHTML = '';
        rows.forEach(row => tbody.appendChild(row));
    }
    
    function getRowValue(row, sortField) {
        switch (sortField) {
            case 'time_limit':
                const timeText = row.querySelector('td:nth-child(3)').textContent;
                return parseInt(timeText.replace(' min', '')) || 0;
            case 'questions':
                return parseInt(row.querySelector('td:nth-child(4)').textContent) || 0;
            case 'created_at':
                const dateText = row.querySelector('td:nth-child(8)').textContent;
                // Convert date string to timestamp for proper sorting
                return new Date(dateText).getTime() || 0;
            default:
                return 0;
        }
    }
});
</script>

<!-- Add this right after the existing script that resets modal title -->
<script defer>
// Update the existing click handler
document.querySelector('[data-bs-target="#addTestModal"]').addEventListener('click', function() {
    // Reset modal title
    document.querySelector('#addTestModal .modal-title').textContent = 'Dodaj nowy szablon testu';
    
    // Get the form
    const form = document.getElementById('addTestForm');
    
    // Reset all form fields
    form.reset();
    
    // Clear title field explicitly (in case it was filled by duplication)
    form.querySelector('[name="title"]').value = '';
    
    // Clear description field explicitly
    form.querySelector('[name="description"]').value = '';
    
    // Reset numeric fields to empty
    form.querySelector('[name="passing_threshold"]').value = '';
    form.querySelector('[name="time_limit_minutes"]').value = '';
    
    // Reset test type to first option
    form.querySelector('[name="test_type"]').selectedIndex = 0;
    
    // Clear questions container
    const questionsContainer = form.querySelector('.questions-container');
    if (questionsContainer) {
        questionsContainer.innerHTML = '';
    }
    
    // Uncheck all group checkboxes
    form.querySelectorAll('input[name="groups[]"]').forEach(checkbox => {
        checkbox.checked = false;
    });
    
    // Reset validation states
    form.querySelectorAll('.is-invalid').forEach(el => {
        el.classList.remove('is-invalid');
    });
    form.querySelectorAll('.border-danger').forEach(el => {
        el.classList.remove('border-danger');
    });
    form.querySelectorAll('.invalid-feedback').forEach(el => {
        el.style.display = 'none';
    });
});
</script>
<script defer>
    document.addEventListener('DOMContentLoaded', function() {
        // Original list.html filtering and sorting code
        const filterTestType = document.getElementById('filterTestType');
        const filterStage = document.getElementById('filterStage');
        const sortBy = document.getElementById('sortBy');
        const sortOrder = document.getElementById('sortOrder');
        const applyFilters = document.getElementById('applyFilters');
        const resetFilters = document.getElementById('resetFilters');
        
        // Store original table rows
        const tbody = document.querySelector('tbody');
        const originalRows = Array.from(tbody.querySelectorAll('tr'));
        
        // Add button click handlers
        applyFilters.addEventListener('click', function() {
            updateTable(true);
        });
        
        resetFilters.addEventListener('click', function() {
            // Reset filter values
            filterTestType.value = '';
            filterStage.value = '';
            filterGroup.value = '';
            sortBy.value = 'created_at';
            sortOrder.value = 'desc';
            
            // Restore original rows and order
            updateTable(false);
        });
        
        function updateTable(applyFilters) {
            const tbody = document.querySelector('tbody');
            
            if (!applyFilters) {
                // Reset to original state
                tbody.innerHTML = '';
                originalRows.forEach(row => {
                    tbody.appendChild(row.cloneNode(true));
                });
                return;
            }
            
            // Clone original rows for filtering
            let rows = originalRows.map(row => row.cloneNode(true));
            
            // Apply filters
            if (filterTestType.value || filterStage.value || filterGroup.value) {
                rows = rows.filter(row => {
                    const testType = row.querySelector('td:first-child').textContent.trim();
                    const stage = row.querySelector('td:nth-child(2)').textContent.trim();
                    const testId = row.dataset.testId;
                    const testGroups = JSON.parse(row.dataset.groups || '[]');
                    
                    const testTypeMatch = !filterTestType.value || 
                        (filterTestType.value === 'SURVEY' && testType === 'Ankieta') ||
                        (filterTestType.value === 'EQ' && testType === 'Test EQ') ||
                        (filterTestType.value === 'IQ' && testType === 'Test IQ');
                        
                    const stageMatch = !filterStage.value || stage === filterStage.value;
                    
                    const groupMatch = !filterGroup.value || 
                        testGroups.some(group => group.id === parseInt(filterGroup.value));
                    
                    return testTypeMatch && stageMatch && groupMatch;
                });
            }
            
            // Apply sorting
            if (sortBy.value) {
                rows.sort((a, b) => {
                    const aValue = getRowValue(a, sortBy.value);
                    const bValue = getRowValue(b, sortBy.value);
                    
                    const order = sortOrder.value === 'asc' ? 1 : -1;
                    
                    if (aValue < bValue) return -1 * order;
                    if (aValue > bValue) return 1 * order;
                    return 0;
                });
            }
            
            // Update table
            tbody.innerHTML = '';
            rows.forEach(row => tbody.appendChild(row));
        }
        
        function getRowValue(row, sortField) {
            switch (sortField) {
                case 'stage':
                    return row.querySelector('td:nth-child(2)').textContent.trim();
                case 'time_limit':
                    return parseInt(row.querySelector('td:nth-child(3)').textContent) || 0;
                case 'questions':
                    return parseInt(row.querySelector('td:nth-child(5)').textContent) || 0;
                case 'created_at':
                    return row.dataset.createdAt || '0';
                default:
                    return 0;
            }
        }
    
        // Initialize Sortable for all question containers
        document.querySelectorAll('.questions-container').forEach(container => {
            initializeSortable(container);
        });
    
        // Handle form submissions
        ['addTestForm', 'editTestForm'].forEach(formId => {
            const form = document.getElementById(formId);
            if (form) {
                form.addEventListener('submit', handleTestFormSubmit);
            }
        });
    
        // Add question button handlers
        document.querySelectorAll('.add-question').forEach(button => {
            button.addEventListener('click', handleAddQuestion);
        });
    
        // Question type change handler
        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('answer-type-select')) {
                handleAnswerTypeChange(e);
            }
        });
    
        // Remove question handler
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('remove-question')) {
                handleRemoveQuestion(e);
            }
        });
    
        checkPendingToast();
    
        // Prevent double click from triggering when clicking buttons
        document.querySelectorAll('.btn-group button').forEach(button => {
            button.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        });
    });
    
    // Functions moved from test.js
    function editTest(testId) {
        fetch(`/tests/${testId}/data`)
            .then(response => response.json())
            .then(test => {
                console.log('Test data received:', test);
                const form = document.getElementById('editTestForm');
                form.action = `/tests/${testId}/edit`;
                
                // Populate basic test fields
                form.querySelector('[name="title"]').value = test.title || '';
                form.querySelector('[name="test_type"]').value = test.test_type || '';
                form.querySelector('[name="description"]').value = test.description || '';
                form.querySelector('[name="passing_threshold"]').value = test.passing_threshold || 0;
                form.querySelector('[name="time_limit_minutes"]').value = test.time_limit_minutes || '';
    
                // Update group checkboxes
                const testGroups = test.groups || [];
                form.querySelectorAll('input[name="groups[]"]').forEach(checkbox => {
                    checkbox.checked = testGroups.some(group => group.id === parseInt(checkbox.value));
                });
    
                // Reset validation state
                const groupsContainer = form.querySelector('#editGroupsContainer');
                if (groupsContainer) {
                    groupsContainer.classList.remove('border-danger');
                }
    
                // Clear and populate questions
                const questionsContainer = form.querySelector('.questions-container');
                questionsContainer.innerHTML = '';
                
                if (test.questions?.length > 0) {
                    test.questions
                        .sort((a, b) => a.order_number - b.order_number)
                        .forEach(question => {
                            const questionHtml = createQuestionHtml(question);
                            questionsContainer.insertAdjacentHTML('beforeend', questionHtml);
                            
                            // After adding HTML, set correct answer based on type
                            const questionCard = questionsContainer.lastElementChild;
                            const answerType = question.answer_type;
                            
                            // Set answer type specific fields
                            switch (answerType) {
                                case 'TEXT':
                                    const textInput = questionCard.querySelector(`[name$="[correct_answer_text]"]`);
                                    if (textInput) textInput.value = question.correct_answer_text || '';
                                    break;
                                    
                                case 'BOOLEAN':
                                    const boolValue = question.correct_answer_boolean;
                                    if (boolValue !== null) {
                                        const radio = questionCard.querySelector(`[name$="[correct_answer_boolean]"][value="${boolValue}"]`);
                                        if (radio) radio.checked = true;
                                    }
                                    break;
                                    
                                case 'SCALE':
                                    const scaleInput = questionCard.querySelector(`[name$="[correct_answer_scale]"]`);
                                    if (scaleInput && question.correct_answer_scale !== null) {
                                        scaleInput.value = question.correct_answer_scale;
                                    }
                                    break;
                                    
                                case 'SALARY':
                                    const salaryInput = questionCard.querySelector(`[name$="[correct_answer_salary]"]`);
                                    if (salaryInput && question.correct_answer_salary !== null) {
                                        salaryInput.value = question.correct_answer_salary;
                                    }
                                    break;
                                    
                                case 'DATE':
                                    const dateInput = questionCard.querySelector(`[name$="[correct_answer_date]"]`);
                                    if (dateInput) dateInput.value = question.correct_answer_date || '';
                                    break;
                                    
                                case 'ABCDEF':
                                    const abcdefSelect = questionCard.querySelector(`[name$="[correct_answer_abcdef]"]`);
                                    if (abcdefSelect) abcdefSelect.value = question.correct_answer_abcdef || '';
                                    break;
                            }
                            
                            // Set image if exists
                            if (question.image) {
                                const imagePreview = questionCard.querySelector('.image-preview');
                                if (imagePreview) {
                                    imagePreview.innerHTML = `
                                        <img src="${question.image}" class="img-thumbnail" style="max-height: 100px">
                                        <input type="hidden" 
                                               name="questions[${questionCard.dataset.questionIndex}][image]"
                                               value="${question.image}">
                                    `;
                                }
                            }
                        });
                }
    
                new bootstrap.Modal(document.getElementById('editTestModal')).show();
            })
            .catch(error => {
                console.error('Error:', error);
                showToast('Błąd podczas ładowania danych testu', 'error');
            });
    }
    
    // Form validation and submission
    ['addTestForm', 'editTestForm'].forEach(formId => {
        const form = document.getElementById(formId);
        if (form) {
            form.addEventListener('submit', function(e) {
                e.preventDefault();
                let isValid = true;
                let errorMessage = '';
    
                // Reset validation states
                form.querySelectorAll('.is-invalid').forEach(el => {
                    el.classList.remove('is-invalid');
                });
                form.querySelectorAll('.border-danger').forEach(el => {
                    el.classList.remove('border-danger');
                });
    
                // Validate required fields
                form.querySelectorAll('[required]').forEach(field => {
                    if (!field.value.trim()) {
                        field.classList.add('is-invalid');
                        isValid = false;
                        errorMessage = 'Uzupełnij wszystkie wymagane pola';
                    }
                });
    
                // Validate passing threshold
                const threshold = form.querySelector('[name="passing_threshold"]');
                if (threshold && (!threshold.value.trim() || isNaN(threshold.value))) {
                    threshold.classList.add('is-invalid');
                    isValid = false;
                    errorMessage = 'Wprowadź poprawny próg zaliczenia';
                }
    
                // Validate groups
                const checkedGroups = form.querySelectorAll('input[name="groups[]"]:checked');
                const groupsContainer = form.querySelector('#groupsContainer');
                if (!checkedGroups.length && groupsContainer) {
                    groupsContainer.classList.add('border-danger');
                    isValid = false;
                    errorMessage = errorMessage || 'Aby zapisać test, musisz wybrać przynajmniej jedną grupę';
                }
    
                if (!isValid) {
                    showToast(errorMessage, 'error');
                    return;
                }
    
                // If everything is valid, submit the form
                const formData = new FormData(form);
                
                // Get questions data
                const questions = [];
                form.querySelectorAll('.question-card').forEach((card, index) => {
                    const questionData = {
                        id: card.dataset.questionId || '',
                        question_text: card.querySelector('[name$="[question_text]"]').value,
                        answer_type: card.querySelector('[name$="[answer_type]"]').value,
                        points: parseInt(card.querySelector('[name$="[points]"]').value || '0'),
                        order_number: index + 1,
                        is_required: card.querySelector('[name$="[is_required]"]').checked,
                        image: card.querySelector('input[name$="[image]"]')?.value || null
                    };
    
                    // Handle answer type specific fields
                    const answerType = questionData.answer_type;
                    switch (answerType) {
                        case 'ABCDEF':
                            const abcdefSelect = card.querySelector('[name$="[correct_answer_abcdef]"]');
                            questionData.correct_answer_abcdef = abcdefSelect ? abcdefSelect.value : null;
                            break;
                        case 'SALARY':
                            const salaryValue = card.querySelector('[name$="[correct_answer_salary]"]')?.value;
                            questionData.correct_answer_salary = salaryValue ? Number(salaryValue) : null;
                            break;
                        default:
                            const answerField = `correct_answer_${answerType.toLowerCase()}`;
                            const answerInput = card.querySelector(`[name$="[${answerField}]"]`);
                            if (answerInput) {
                                questionData[answerField] = answerInput.type === 'checkbox' ? 
                                    answerInput.checked : answerInput.value;
                            }
                    }
    
                    questions.push(questionData);
                });
    
                formData.append('questions', JSON.stringify(questions));
    
                fetch(form.action, {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        window.location.reload();
                    } else {
                        throw new Error(data.error || 'Wystąpił błąd podczas zapisywania');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showToast(error.message || 'Wystąpił błąd podczas zapisywania', 'error');
                });
            });
    
            // Reset validation state when any checkbox is clicked
            form.querySelectorAll('.group-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const groupsContainer = this.closest('#groupsContainer');
                    if (groupsContainer) {
                        groupsContainer.classList.remove('border-danger');
                    }
                });
            });
        }
    });
    
    // Helper functions
    function createQuestionHtml(question = null) {
        const q = question || {};
        const questionCounter = document.querySelectorAll('.question-card').length;
        
        return `
            <div class="card mb-2 question-card" data-question-id="${q.id || ''}" 
                 data-order="${q.order_number || questionCounter + 1}">
                <input type="hidden" name="questions[${questionCounter}][id]" value="${q.id || ''}">
                <input type="hidden" name="questions[${questionCounter}][order_number]" 
                       value="${q.order_number || questionCounter + 1}">
                
                <div class="card-header d-flex justify-content-between align-items-center">
                    <div class="form-check form-switch">
                        <input type="checkbox" class="form-check-input" 
                               name="questions[${questionCounter}][is_required]"
                               ${q.is_required !== false ? 'checked' : ''}>
                        <label class="form-check-label">Pytanie obowiązkowe</label>
                    </div>
                    <button type="button" class="btn btn-danger btn-sm remove-question">
                        Usuń pytanie
                    </button>
                </div>
                
                <div class="card-body">
                    <div class="d-flex">
                        <div class="drag-handle me-3 d-flex align-items-center" 
                             title="Przeciągnij aby zmienić kolejność"
                             style="cursor: move;">☰</div>
                        
                        <div class="border-start ps-3 flex-grow-1">
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label class="form-label">Treść pytania*</label>
                                    <input type="text" class="form-control" 
                                           name="questions[${questionCounter}][question_text]"
                                           value="${q.question_text || ''}" required>
                                </div>
                            </div>
                            
                            <!-- Add image upload field -->
                            <div class="row mb-3">
                                <div class="col-12">
                                    <label class="form-label">Obrazek</label>
                                    <input type="file" class="form-control" 
                                           name="questions[${questionCounter}][image_file]"
                                           accept="image/*"
                                           onchange="handleImageUpload(this)">
                                    ${q.image ? `
                                        <div class="mt-2 image-preview">
                                            <img src="${q.image}" class="img-thumbnail" style="max-height: 100px">
                                            <input type="hidden" 
                                                   name="questions[${questionCounter}][image]"
                                                   value="${q.image}">
                                        </div>` : ''}
                                </div>
                            </div>
                            
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <label class="form-label">Typ odpowiedzi*</label>
                                    <select class="form-select answer-type-select" 
                                            name="questions[${questionCounter}][answer_type]" required>
                                        <option value="TEXT" ${q.answer_type === 'TEXT' ? 'selected' : ''}>Tekst</option>
                                        <option value="BOOLEAN" ${q.answer_type === 'BOOLEAN' ? 'selected' : ''}>Tak/Nie</option>
                                        <option value="SCALE" ${q.answer_type === 'SCALE' ? 'selected' : ''}>Skala (0-5)</option>
                                        <option value="SALARY" ${q.answer_type === 'SALARY' ? 'selected' : ''}>Wynagrodzenie (PLN)</option>
                                        <option value="DATE" ${q.answer_type === 'DATE' ? 'selected' : ''}>Data</option>
                                        <option value="ABCDEF" ${q.answer_type === 'ABCDEF' ? 'selected' : ''}>ABCDEF</option>
                                        <option value="AH_POINTS" ${q.answer_type === 'AH_POINTS' ? 'selected' : ''}>Test EQ (A-H)</option>
                                    </select>
                                </div>
                                <div class="col-md-8">
                                    <!-- Dynamic answer fields container -->
                                    <div class="answer-fields">
                                        ${createAnswerFieldsHtml(questionCounter, q)}
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row">
                                <div class="col-md-4">
                                    <label class="form-label">Punkty za pytanie*</label>
                                    <input type="number" class="form-control" 
                                           name="questions[${questionCounter}][points]"
                                           value="${q.points || '0'}" 
                                           min="0"
                                           required>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function createAnswerFieldsHtml(questionCounter, question) {
        const answerType = question?.answer_type || 'TEXT';
        let html = '';
        
        switch (answerType) {
            case 'AH_POINTS':
                const options = question?.options || '';
                
                html = `
                    <div class="row">
                        <div class="col-12">
                            <label class="form-label">Opcje odpowiedzi (A-H)*</label>
                            <div class="options-container">
                                ${['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'].map(letter => {
                                    const letterLower = letter.toLowerCase();
                                    return `
                                        <div class="option-row">
                                            <div class="option-letter">${letter}.</div>
                                            <div class="option-input">
                                                <input type="text" 
                                                       class="form-control"
                                                       name="questions[${questionCounter}][options][${letterLower}]"
                                                       value="${options[letterLower] || ''}"
                                                       placeholder="Treść opcji ${letter}"
                                                       required>
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
                break;
                    
            case 'BOOLEAN':
                html = `
                    <div>
                        <label class="form-label">Poprawna odpowiedź</label>
                        <div class="form-check">
                            <input type="radio" class="form-check-input" 
                                   name="questions[${questionCounter}][correct_answer_boolean]" 
                                   value="true" ${question?.correct_answer_boolean === true ? 'checked' : ''}>
                            <label class="form-check-label">Prawda</label>
                        </div>
                        <div class="form-check">
                            <input type="radio" class="form-check-input" 
                                   name="questions[${questionCounter}][correct_answer_boolean]" 
                                   value="false" ${question?.correct_answer_boolean === false ? 'checked' : ''}>
                            <label class="form-check-label">Fałsz</label>
                        </div>
                    </div>
                `;
                break;
                    
            case 'SCALE':
                html = `
                    <div class="row">
                        <div class="col-md-6">
                            <label class="form-label">Poprawna odpowiedź (0-5)</label>
                            <input type="number" class="form-control" 
                                   name="questions[${questionCounter}][correct_answer_scale]"
                                   min="0" max="5" 
                                   value="${question?.correct_answer_scale || ''}">
                        </div>
                    </div>
                `;
                break;
                    
            case 'SALARY':
                html = `
                    <div class="row">
                        <div class="col-md-6">
                            <label class="form-label">Poprawna odpowiedź (PLN)</label>
                            <input type="number" class="form-control" 
                                   name="questions[${questionCounter}][correct_answer_salary]"
                                   min="0" step="100" 
                                   value="${question?.correct_answer_salary !== null ? question.correct_answer_salary : ''}">
                        </div>
                    </div>
                `;
                break;
                    
            case 'DATE':
                html = `
                    <div class="row">
                        <div class="col-md-6">
                            <label class="form-label">Poprawna data</label>
                            <input type="date" class="form-control" 
                                   name="questions[${questionCounter}][correct_answer_date]"
                                   value="${question?.correct_answer_date || ''}">
                        </div>
                    </div>
                `;
                break;
                    
            default: // TEXT
                html = `
                    <div class="row">
                        <div class="col-md-12">
                            <label class="form-label">Poprawna odpowiedź tekstowa</label>
                            <input type="text" class="form-control" 
                                   name="questions[${questionCounter}][correct_answer_text]"
                                   value="${question?.correct_answer_text || ''}">
                        </div>
                    </div>
                `;
        }
        
        return html;
    }
    
    function handleAnswerTypeChange(e) {
        const questionCard = e.target.closest('.question-card');
        const answerFieldsContainer = questionCard.querySelector('.answer-fields');
        const questionCounter = Array.from(questionCard.parentElement.children).indexOf(questionCard);
        
        answerFieldsContainer.innerHTML = createAnswerFieldsHtml(questionCounter, {
            answer_type: e.target.value
        });
    }
    
    function handleAddQuestion(e) {
        const container = e.target.closest('.questions-section').querySelector('.questions-container');
        const questionHtml = createQuestionHtml();
        container.insertAdjacentHTML('beforeend', questionHtml);
    }
    
    function handleRemoveQuestion(e) {
        if (confirm('Czy na pewno chcesz usunąć to pytanie?')) {
            const questionCard = e.target.closest('.question-card');
            questionCard.remove();
        }
    }
    
    function handleTestFormSubmit(e) {
        e.preventDefault();
        const form = this;
        const formData = new FormData(form);
        const isEdit = form.id === 'editTestForm';
        
        // Debug logging for form data
        console.log('Form data before submission:');
        for (let pair of formData.entries()) {
            console.log(pair[0], pair[1]);
        }
        
        // Add questions data
        const questions = [];
        form.querySelectorAll('.question-card').forEach((card, index) => {
            const questionData = {
                id: card.dataset.questionId || '',
                question_text: card.querySelector('[name$="[question_text]"]').value,
                answer_type: card.querySelector('[name$="[answer_type]"]').value,
                points: parseInt(card.querySelector('[name$="[points]"]').value || '0'),
                order_number: index + 1,
                is_required: card.querySelector('[name$="[is_required]"]').checked,
                image: card.querySelector('input[name$="[image]"]')?.value || null
            };
    
            // Handle answer type specific fields
            const answerType = questionData.answer_type;
            switch (answerType) {
                case 'ABCDEF':
                    const abcdefSelect = card.querySelector('[name$="[correct_answer_abcdef]"]');
                    questionData.correct_answer_abcdef = abcdefSelect ? abcdefSelect.value : null;
                    console.log('ABCDEF answer value:', questionData.correct_answer_abcdef); // Debug log
                    break;
                case 'SALARY':
                    const salaryValue = card.querySelector('[name$="[correct_answer_salary]"]')?.value;
                    questionData.correct_answer_salary = salaryValue ? Number(salaryValue) : null;
                    break;
                default:
                    const answerField = `correct_answer_${answerType.toLowerCase()}`;
                    const answerInput = card.querySelector(`[name$="[${answerField}]"]`);
                    if (answerInput) {
                        questionData[answerField] = answerInput.value;
                    }
            }
    
            questions.push(questionData);
        });
    
        console.log('Questions data before submit:', questions); // Debug log
        formData.append('questions', JSON.stringify(questions));
        
        fetch(form.action, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Store toast message in sessionStorage
                sessionStorage.setItem('pendingToast', JSON.stringify({
                    message: data.message || (isEdit ? 'Test został zaktualizowany' : 'Test został dodany'),
                    type: 'success'
                }));
    
                // Close modal before reload
                const modal = bootstrap.Modal.getInstance(form.closest('.modal'));
                modal.hide();
                
                // Reload after modal is hidden
                modal._element.addEventListener('hidden.bs.modal', function () {
                    window.location.reload();
                }, { once: true });
            } else {
                throw new Error(data.error || 'Wystąpił błąd');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            showToast(error.message, 'error');
            
            // Reset button state
            submitButton.disabled = false;
            spinner.classList.add('d-none');
            buttonText.textContent = isEdit ? 'Zapisz zmiany' : 'Zapisz test';
        });
    }
    
    function confirmDeleteTest(testId) {
        if (confirm('Czy na pewno chcesz usunąć ten test?')) {
            fetch(`/tests/${testId}/delete`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Test został usunięty', 'success');
                    document.querySelector(`tr[data-test-id="${testId}"]`).remove();
                } else {
                    throw new Error(data.error || 'Wystąpił błąd podczas usuwania testu');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showToast(error.message, 'error');
            });
        }
    }
    
    function showToast(message, type = 'success') {
        const toast = document.getElementById('notificationToast');
        const toastMessage = document.getElementById('toastMessage');
        
        // Reset classes
        toast.className = 'toast border-0';
        
        // Add styling based on type
        if (type === 'success') {
            toast.style.backgroundColor = '#198754';  // Bootstrap success color
            toast.style.borderLeft = '4px solid #146c43';  // Darker shade
        } else {
            toast.style.backgroundColor = '#dc3545';  // Bootstrap danger color
            toast.style.borderLeft = '4px solid #b02a37';  // Darker shade
        }
        
        // Add common styles
        toast.classList.add('text-white');
        
        // Set message
        toastMessage.textContent = message;
        
        // Show toast
        const bsToast = new bootstrap.Toast(toast);
        bsToast.show();
    }
    
    function initializeSortable(container) {
        if (container.sortableInstance) {
            container.sortableInstance.destroy();
        }
        
        container.sortableInstance = new Sortable(container, {
            animation: 150,
            handle: '.drag-handle',
            onEnd: function(evt) {
                updateQuestionOrders(container);
            }
        });
    }
    
    function updateQuestionOrders(container) {
        container.querySelectorAll('.question-card').forEach((card, index) => {
            card.dataset.order = index + 1;
            card.querySelector('input[name$="[order_number]"]').value = index + 1;
        });
    }
    
    function convertToBase64(fileInput, fieldName) {
        const file = fileInput.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64String = e.target.result;
                const questionCard = fileInput.closest('.question-card');
                const hiddenInput = questionCard.querySelector(`input[name$="[${fieldName}]"]`) || 
                                   document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = fileInput.name.replace('_file', '').replace('_image', '');
                hiddenInput.value = base64String;
                
                const previewContainer = fileInput.nextElementSibling || document.createElement('div');
                previewContainer.className = 'mt-2';
                previewContainer.innerHTML = `
                    <img src="${base64String}" class="img-thumbnail" style="max-height: 100px">
                `;
                
                if (!fileInput.nextElementSibling) {
                    fileInput.parentNode.appendChild(previewContainer);
                }
                if (!questionCard.querySelector(`input[name$="[${fieldName}]"]`)) {
                    questionCard.appendChild(hiddenInput);
                }
            };
            reader.readAsDataURL(file);
        }
    }
    
    function checkPendingToast() {
        const pendingToast = sessionStorage.getItem('pendingToast');
        if (pendingToast) {
            try {
                const toastData = JSON.parse(pendingToast);
                showToast(toastData.message, toastData.type);
            } catch (error) {
                console.error('Error showing pending toast:', error);
            } finally {
                sessionStorage.removeItem('pendingToast');
            }
        }
    }
    
    // Add image handling function
    function handleImageUpload(input) {
        const file = input.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const base64String = e.target.result;
                const questionCard = input.closest('.question-card');
                
                // Create or update hidden input for image data
                const hiddenInput = questionCard.querySelector('input[name$="[image]"]') || 
                                  document.createElement('input');
                hiddenInput.type = 'hidden';
                hiddenInput.name = input.name.replace('_file', '');
                hiddenInput.value = base64String;
                
                // Create or update preview container
                let previewContainer = questionCard.querySelector('.image-preview');
                if (!previewContainer) {
                    previewContainer = document.createElement('div');
                    previewContainer.className = 'mt-2 image-preview';
                    input.parentNode.insertBefore(previewContainer, input.nextSibling);
                }
                
                // Update preview
                previewContainer.innerHTML = `
                    <img src="${base64String}" class="img-thumbnail" style="max-height: 100px">
                `;
                
                // Ensure hidden input is in the form
                if (!questionCard.querySelector(`input[name$="[image]"]`)) {
                    questionCard.appendChild(hiddenInput);
                }
                
                console.log('Image uploaded and converted to base64');
            };
            reader.readAsDataURL(file);
        }
    }
    
    // Add form validation for groups
    document.addEventListener('DOMContentLoaded', function() {
        ['addTestForm', 'editTestForm'].forEach(formId => {
            const form = document.getElementById(formId);
            if (form) {
                form.addEventListener('submit', function(e) {
                    const checkedGroups = form.querySelectorAll('input[name="groups[]"]:checked');
                    const groupsContainer = form.querySelector(form.id === 'addTestForm' ? '#addGroupsContainer' : '#editGroupsContainer');
                    const feedbackDiv = groupsContainer.nextElementSibling;
                    
                    if (!checkedGroups.length) {
                        e.preventDefault();
                        groupsContainer.classList.add('border-danger');
                        feedbackDiv.style.display = 'block';
                        showToast('Należy wybrać co najmniej jedną grupę', 'error');
                        return;
                    }
                    
                    groupsContainer.classList.remove('border-danger');
                    feedbackDiv.style.display = 'none';
                });
            }
        });
    });
    
    function duplicateTest(testId) {
        fetch(`/tests/${testId}/data`)
            .then(response => response.json())
            .then(test => {
                const form = document.getElementById('addTestForm');
                
                // Populate form fields except unique identifiers
                form.querySelector('[name="title"]').value = test.title ? `${test.title} - kopia` : '';
                form.querySelector('[name="test_type"]').value = test.test_type || '';
                form.querySelector('[name="description"]').value = test.description || '';
                form.querySelector('[name="passing_threshold"]').value = test.passing_threshold || 0;
                form.querySelector('[name="time_limit_minutes"]').value = test.time_limit_minutes || '';
    
                // Set groups
                if (test.groups) {
                    test.groups.forEach(group => {
                        const checkbox = form.querySelector(`input[name="groups[]"][value="${group.id}"]`);
                        if (checkbox) checkbox.checked = true;
                    });
                }
    
                // Clear existing questions container
                const questionsContainer = form.querySelector('.questions-container');
                questionsContainer.innerHTML = '';
    
                // Add questions
                if (test.questions && test.questions.length > 0) {
                    test.questions
                        .sort((a, b) => a.order_number - b.order_number)
                        .forEach(question => {
                            // Remove ID from question to create new one
                            delete question.id;
                            const questionHtml = createQuestionHtml(question);
                            questionsContainer.insertAdjacentHTML('beforeend', questionHtml);
    
                            // Set answer type specific fields
                            const questionCard = questionsContainer.lastElementChild;
                            const answerType = question.answer_type;
                            
                            switch (answerType) {
                                case 'TEXT':
                                    const textInput = questionCard.querySelector(`[name$="[correct_answer_text]"]`);
                                    if (textInput) textInput.value = question.correct_answer_text || '';
                                    break;
                                    
                                case 'BOOLEAN':
                                    const boolValue = question.correct_answer_boolean;
                                    if (boolValue !== null) {
                                        const radio = questionCard.querySelector(`[name$="[correct_answer_boolean]"][value="${boolValue}"]`);
                                        if (radio) radio.checked = true;
                                    }
                                    break;
                                    
                                case 'SCALE':
                                    const scaleInput = questionCard.querySelector(`[name$="[correct_answer_scale]"]`);
                                    if (scaleInput && question.correct_answer_scale !== null) {
                                        scaleInput.value = question.correct_answer_scale;
                                    }
                                    break;
                                    
                                case 'SALARY':
                                    const salaryInput = questionCard.querySelector(`[name$="[correct_answer_salary]"]`);
                                    if (salaryInput && question.correct_answer_salary !== null) {
                                        salaryInput.value = question.correct_answer_salary;
                                    }
                                    break;
                                    
                                case 'DATE':
                                    const dateInput = questionCard.querySelector(`[name$="[correct_answer_date]"]`);
                                    if (dateInput) dateInput.value = question.correct_answer_date || '';
                                    break;
                                    
                                case 'ABCDEF':
                                    const abcdefSelect = questionCard.querySelector(`[name$="[correct_answer_abcdef]"]`);
                                    if (abcdefSelect) abcdefSelect.value = question.correct_answer_abcdef || '';
                                    break;
                            }
    
                            // Handle image if exists
                            if (question.image) {
                                const imagePreview = questionCard.querySelector('.image-preview');
                                if (imagePreview) {
                                    imagePreview.innerHTML = `
                                        <img src="${question.image}" class="img-thumbnail" style="max-height: 100px">
                                        <input type="hidden" 
                                               name="questions[${questionCard.dataset.questionIndex}][image]"
                                               value="${question.image}">
                                    `;
                                }
                            }
                        });
                }
    
                // Update modal title to indicate duplication
                document.querySelector('#addTestModal .modal-title').textContent = 'Duplikuj szablon testu';
                
                // Show the modal
                new bootstrap.Modal(document.getElementById('addTestModal')).show();
            })
            .catch(error => {
                console.error('Error:', error);
                showToast('Błąd podczas ładowania danych testu', 'error');
            });
    }
    
    // Add this to reset modal title when opening normally
    document.querySelector('[data-bs-target="#addTestModal"]').addEventListener('click', function() {
        document.querySelector('#addTestModal .modal-title').textContent = 'Dodaj nowy szablon testu';
    });
    </script>

{% endblock %}

{% block head %}
{{ super() }}
<style>
    .table tbody tr:hover {
        background-color: rgba(0,0,0,.075);
    }
    
    /* Add this new style */
    .text-muted {
        font-size: 0.85em;
        color: #9ca3af !important;
    }
    
    .options-container {
        padding: 15px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
    }
    
    .option-row {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
    }
    
    .option-row:last-child {
        margin-bottom: 0;
    }
    
    .option-letter {
        width: 30px;
        font-weight: bold;
        color: #495057;
    }
    
    .option-input {
        flex: 1;
    }
</style>
{% endblock %} 